#!/usr/bin/env node

if (process.env.NEW_RELIC_LICENSE_KEY) {
  console.warn('Starting newrelic agent with key: ', process.env.NEW_RELIC_LICENSE_KEY);
  require('newrelic');
}
require("babel/register");
const Hull = require('hull');
const Server = require('../server');
const PORT = process.env.PORT || 8082;

const options = {
  Hull,
  secret: process.env.SECRET,
  devMode: process.env.NODE_ENV == 'development',
  measure: function() {}
}

if (process.env.LIBRATO_TOKEN && process.env.LIBRATO_USER) {
  var librato = require('librato-node');
  librato.configure({
    email: process.env.LIBRATO_USER,
    token: process.env.LIBRATO_TOKEN
  });
  librato.on('error', function(err) {
    console.error(err);
  });

  process.once('SIGINT', function() {
    librato.stop(); // stop optionally takes a callback
  });
  librato.start();
  options.measure = function(metric, value, options) {
    try {
      librato && librato.measure(metric, value, options);
    } catch(err) {
      console.warn('error in librato.measure', err);
    }
  }
}


options.log = function(msg, data) {
  const payload = typeof(data) === 'object' ? JSON.stringify(data) : data;
  console.warn(msg, payload);
}

const app = Server(options);

function exitNow() {
  console.warn('Exiting now !');
  process.exit();
}

function handleExit() {
  console.log("Exiting... waiting 30 seconds workers to flush");
  setTimeout(exitNow, 30000);
  app.exit().then(exitNow);
}


process.on('SIGINT', handleExit);
process.on('SIGTERM', handleExit);

console.log('Listening on port ' + PORT);
app.listen(PORT);
